/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SPLSyntaxPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// src/spl-tokens.ts
var SPL_COMMANDS = /* @__PURE__ */ new Set([
  // Transforming Commands
  "stats",
  "chart",
  "timechart",
  "top",
  "rare",
  "contingency",
  "highlight",
  "addtotals",
  "addcoltotals",
  "bin",
  "bucket",
  "eventstats",
  "streamstats",
  "geostats",
  "mstats",
  "sichart",
  "sitimechart",
  "tstats",
  "xyseries",
  "untable",
  // Generating Commands
  "search",
  "inputlookup",
  "inputcsv",
  "makeresults",
  "metadata",
  "rest",
  "datamodel",
  "pivot",
  "loadjob",
  "savedsearch",
  "gentimes",
  "dbinspect",
  // Streaming Commands
  "eval",
  "rex",
  "rename",
  "fields",
  "table",
  "where",
  "regex",
  "replace",
  "convert",
  "fillnull",
  "makemv",
  "mvexpand",
  "nomv",
  "split",
  "strcat",
  "dedup",
  "head",
  "tail",
  "sort",
  "reverse",
  "uniq",
  "spath",
  "xmlkv",
  // Reporting Commands
  "transaction",
  "cluster",
  "kmeans",
  "anomalies",
  "predict",
  "trendline",
  "associate",
  "correlate",
  "analyzefields",
  "anomalousvalue",
  // Subsearch/Macro Commands
  "append",
  "appendcols",
  "appendpipe",
  "join",
  "lookup",
  "outputlookup",
  "map",
  "foreach",
  "return",
  "format",
  "multisearch",
  // Data Management Commands
  "collect",
  "delete",
  "sendemail",
  "outputcsv",
  "outputtext",
  // Additional Commands
  "abstract",
  "accum",
  "addinfo",
  "arules",
  "audit",
  "autoregress",
  "bucketdir",
  "cefout",
  "cofilter",
  "concurrency",
  "crawl",
  "dbxquery",
  "diff",
  "erex",
  "eventcount",
  "eventtypes",
  "extract",
  "fieldformat",
  "fieldsummary",
  "file",
  "filldown",
  "findtypes",
  "folderize",
  "gauge",
  "geom",
  "getfield",
  "history",
  "iconify",
  "inputintelligence",
  "iplocation",
  "kv",
  "kvform",
  "localize",
  "localop",
  "makecontinuous",
  "mcollect",
  "meventcollect",
  "mpreview",
  "msearch",
  "multikv",
  "mvcombine",
  "mvjoin",
  "overlap",
  "outputtelemetry",
  "outlier",
  "rangemap",
  "redistribute",
  "reltime",
  "require",
  "rtorder",
  "run",
  "runshellscript",
  "savedsearches",
  "scrub",
  "searchtxn",
  "selfjoin",
  "sendalert",
  "set",
  "setfields",
  "sistats",
  "sperf",
  "srctype",
  "strptime",
  "tags",
  "teragrep",
  "timewrap",
  "tojson",
  "transpose",
  "trendline",
  "tscollect",
  "typeahead",
  "typelearner",
  "typer",
  "union",
  "walklex",
  "x11",
  "xmlunescape",
  "xpath",
  "xsDisplayConcept",
  "xsDisplayContext",
  "xsFindBestConcept",
  "xsListConcepts",
  "xsListContexts",
  "xsUpdateDDContext",
  "xsWhere"
]);
var SPL_FUNCTIONS = /* @__PURE__ */ new Set([
  // Comparison and Conditional Functions
  "case",
  "cidrmatch",
  "coalesce",
  "false",
  "if",
  "ifnull",
  "in",
  "like",
  "lookup",
  "match",
  "null",
  "nullif",
  "searchmatch",
  "true",
  "validate",
  // Conversion Functions
  "ipmask",
  "printf",
  "tonumber",
  "tostring",
  // Cryptographic Functions
  "md5",
  "sha1",
  "sha256",
  "sha512",
  // Date and Time Functions
  "now",
  "relative_time",
  "strftime",
  "strptime",
  "time",
  // Informational Functions
  "isbool",
  "isint",
  "isnotnull",
  "isnull",
  "isnum",
  "isstr",
  "typeof",
  // JSON Functions
  "json_object",
  "json_array",
  "json_extract",
  "json_keys",
  "json_set",
  "json_valid",
  "json_append",
  "json_extend",
  "json_extract_exact",
  // Mathematical Functions
  "abs",
  "ceiling",
  "ceil",
  "exact",
  "exp",
  "floor",
  "ln",
  "log",
  "pi",
  "pow",
  "round",
  "sigfig",
  "sqrt",
  "sum",
  // Multivalue Functions
  "commands",
  "mvappend",
  "mvcount",
  "mvdedup",
  "mvfilter",
  "mvfind",
  "mvindex",
  "mvjoin",
  "mvmap",
  "mvrange",
  "mvsort",
  "mvzip",
  // Statistical Functions (for stats, eventstats, streamstats, etc.)
  "avg",
  "count",
  "dc",
  "distinct_count",
  "distinctcount",
  "earliest",
  "earliest_time",
  "estdc",
  "estdc_error",
  "first",
  "last",
  "latest",
  "latest_time",
  "list",
  "max",
  "mean",
  "median",
  "min",
  "mode",
  "p",
  "perc",
  "percentile",
  "range",
  "rate",
  "stdev",
  "stdevp",
  "sumsq",
  "values",
  "var",
  "varp",
  // Text Functions
  "len",
  "lenght",
  "lower",
  "ltrim",
  "replace",
  "rtrim",
  "spath",
  "split",
  "substr",
  "trim",
  "upper",
  "urldecode",
  "urlencode",
  // Trigonometry and Hyperbolic Functions
  "acos",
  "acosh",
  "asin",
  "asinh",
  "atan",
  "atan2",
  "atanh",
  "cos",
  "cosh",
  "hypot",
  "sin",
  "sinh",
  "tan",
  "tanh",
  // Other Functions
  "random",
  "relative_time",
  "spath",
  "xpath"
]);
var SPL_KEYWORDS = /* @__PURE__ */ new Set([
  // Boolean Operators
  "and",
  "or",
  "not",
  "xor",
  // Clause Keywords
  "as",
  "by",
  "over",
  "where",
  "output",
  "outputnew",
  "from",
  "to",
  "with",
  "into",
  "on",
  "using",
  "having",
  "groupby",
  "orderby",
  // Boolean Values
  "true",
  "false",
  "null",
  // Time Keywords
  "earliest",
  "latest",
  "starttime",
  "endtime",
  // Special Keywords
  "allnum",
  "delim",
  "keepevents",
  "consecutive",
  "maxspan",
  "maxpause",
  "startswith",
  "endswith",
  "mvlist",
  "usenull",
  "useother",
  "otherstr",
  "limit",
  "showcount",
  "showperc",
  "countfield",
  "percentfield",
  "dc",
  "partitions",
  "allnum",
  "default",
  "timeformat",
  "cont",
  "span",
  "bins",
  "minspan",
  "start",
  "end",
  "aligntime"
]);

// src/main.ts
var import_view2 = require("@codemirror/view");
var decorations = {
  keyword: import_view.Decoration.mark({ class: "spl-keyword" }),
  builtin: import_view.Decoration.mark({ class: "spl-builtin" }),
  atom: import_view.Decoration.mark({ class: "spl-atom" }),
  operator: import_view.Decoration.mark({ class: "spl-operator" }),
  punctuation: import_view.Decoration.mark({ class: "spl-punctuation" }),
  string: import_view.Decoration.mark({ class: "spl-string" }),
  number: import_view.Decoration.mark({ class: "spl-number" }),
  variable: import_view.Decoration.mark({ class: "spl-variable" }),
  meta: import_view.Decoration.mark({ class: "spl-meta" }),
  comment: import_view.Decoration.mark({ class: "spl-comment" }),
  bracket: import_view.Decoration.mark({ class: "spl-bracket" })
};
var STATS_COMMANDS = /* @__PURE__ */ new Set([
  "stats",
  "eventstats",
  "streamstats",
  "sistats",
  "mstats",
  "tstats",
  "chart",
  "timechart",
  "sichart",
  "sitimechart",
  "geostats",
  "top",
  "rare"
]);
function tokenizeSPL(code) {
  const tokens = [];
  let pos = 0;
  let expectCommand = true;
  let inStatsCommand = false;
  while (pos < code.length) {
    const wsMatch = code.slice(pos).match(/^\s+/);
    if (wsMatch) {
      pos += wsMatch[0].length;
      continue;
    }
    if (code[pos] === "`" && code[pos + 1] === "`" && code[pos + 2] === "`") {
      const closeIdx = code.indexOf("```", pos + 3);
      if (closeIdx !== -1) {
        const end = closeIdx + 3;
        tokens.push({ start: pos, end, type: "comment" });
        pos = end;
        continue;
      }
    }
    if (code[pos] === "`" && code[pos + 1] !== "`") {
      const macroMatch = code.slice(pos).match(/^`[^`\n]*`/);
      if (macroMatch) {
        tokens.push({ start: pos, end: pos + macroMatch[0].length, type: "meta" });
        pos += macroMatch[0].length;
        expectCommand = false;
        continue;
      }
    }
    if (code[pos] === "|") {
      tokens.push({ start: pos, end: pos + 1, type: "punctuation" });
      pos++;
      expectCommand = true;
      inStatsCommand = false;
      continue;
    }
    if (code[pos] === '"') {
      let end = pos + 1;
      while (end < code.length && code[end] !== '"' && code[end] !== "\n") {
        if (code[end] === "\\" && end + 1 < code.length)
          end++;
        end++;
      }
      if (end < code.length && code[end] === '"')
        end++;
      tokens.push({ start: pos, end, type: "string" });
      pos = end;
      expectCommand = false;
      continue;
    }
    if (code[pos] === "'") {
      let end = pos + 1;
      while (end < code.length && code[end] !== "'" && code[end] !== "\n") {
        if (code[end] === "\\" && end + 1 < code.length)
          end++;
        end++;
      }
      if (end < code.length && code[end] === "'")
        end++;
      tokens.push({ start: pos, end, type: "string" });
      pos = end;
      expectCommand = false;
      continue;
    }
    const numMatch = code.slice(pos).match(/^-?\d+(\.\d+)?([eE][+-]?\d+)?/);
    if (numMatch) {
      const afterNum = code[pos + numMatch[0].length];
      if (afterNum && /[a-zA-Z_]/.test(afterNum)) {
        const fieldMatch = code.slice(pos).match(/^[\w._]+/);
        if (fieldMatch) {
          tokens.push({ start: pos, end: pos + fieldMatch[0].length, type: "variable" });
          pos += fieldMatch[0].length;
          expectCommand = false;
          continue;
        }
      }
      tokens.push({ start: pos, end: pos + numMatch[0].length, type: "number" });
      pos += numMatch[0].length;
      expectCommand = false;
      continue;
    }
    if (code.slice(pos, pos + 2).match(/^(==|!=|<=|>=|<>)/)) {
      tokens.push({ start: pos, end: pos + 2, type: "operator" });
      pos += 2;
      expectCommand = false;
      continue;
    }
    if ("<>=!+-*/%".includes(code[pos])) {
      tokens.push({ start: pos, end: pos + 1, type: "operator" });
      pos++;
      expectCommand = false;
      continue;
    }
    if (code[pos] === "[") {
      tokens.push({ start: pos, end: pos + 1, type: "bracket" });
      pos++;
      expectCommand = true;
      inStatsCommand = false;
      continue;
    }
    if ("](){}".includes(code[pos])) {
      tokens.push({ start: pos, end: pos + 1, type: "bracket" });
      pos++;
      expectCommand = false;
      continue;
    }
    if (code[pos] === ",") {
      tokens.push({ start: pos, end: pos + 1, type: "punctuation" });
      pos++;
      expectCommand = false;
      continue;
    }
    const wordMatch = code.slice(pos).match(/^[a-zA-Z_][\w._]*/);
    if (wordMatch) {
      const word = wordMatch[0].toLowerCase();
      let type = "variable";
      const afterWord = code.slice(pos + wordMatch[0].length).match(/^\s*(.)/);
      const nextChar = afterWord ? afterWord[1] : "";
      if (expectCommand && SPL_COMMANDS.has(word)) {
        type = "keyword";
        if (STATS_COMMANDS.has(word)) {
          inStatsCommand = true;
        }
      } else if (SPL_FUNCTIONS.has(word)) {
        if (nextChar === "(" || inStatsCommand) {
          type = "builtin";
        }
      } else if (SPL_KEYWORDS.has(word)) {
        type = "atom";
        if (word === "by") {
          inStatsCommand = false;
        }
      }
      tokens.push({ start: pos, end: pos + wordMatch[0].length, type });
      pos += wordMatch[0].length;
      expectCommand = false;
      continue;
    }
    if (code[pos] === "*") {
      tokens.push({ start: pos, end: pos + 1, type: "operator" });
      pos++;
      expectCommand = false;
      continue;
    }
    pos++;
  }
  return tokens;
}
function findSPLCodeBlocks(text) {
  const blocks = [];
  const regex = /(`{3,})(?:spl|splunk)\s*\n([\s\S]*?)\1/gi;
  let match;
  while ((match = regex.exec(text)) !== null) {
    const fullMatch = match[0];
    const codeContent = match[2];
    const headerEnd = match[0].indexOf("\n") + 1;
    const contentStart = match.index + headerEnd;
    const contentEnd = contentStart + codeContent.length;
    blocks.push({
      contentStart,
      contentEnd,
      content: codeContent
    });
  }
  return blocks;
}
function buildSPLDecorations(view) {
  const builder = new import_state.RangeSetBuilder();
  const text = view.state.doc.toString();
  const blocks = findSPLCodeBlocks(text);
  for (const block of blocks) {
    const tokens = tokenizeSPL(block.content);
    for (const token of tokens) {
      const from = block.contentStart + token.start;
      const to = block.contentStart + token.end;
      const deco = decorations[token.type];
      if (deco && from >= 0 && to <= view.state.doc.length && from < to) {
        builder.add(from, to, deco);
      }
    }
  }
  return builder.finish();
}
var splDecorationField = import_state.StateField.define({
  create(state) {
    return import_view.Decoration.none;
  },
  update(decorations2, tr) {
    return decorations2;
  },
  provide(field) {
    return import_view.EditorView.decorations.from(field);
  }
});
var splHighlightExtension = import_view.EditorView.updateListener.of((update) => {
  if (update.docChanged || update.viewportChanged) {
    const decorations2 = buildSPLDecorations(update.view);
  }
});
var SPLHighlightPluginValue = class {
  constructor(view) {
    this.decorations = buildSPLDecorations(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.startState.doc !== update.state.doc) {
      this.decorations = buildSPLDecorations(update.view);
    }
  }
  destroy() {
  }
};
var splViewPlugin = import_view2.ViewPlugin.fromClass(SPLHighlightPluginValue, {
  decorations: (v) => v.decorations
});
var SPLSyntaxPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.registerEditorExtension([import_state.Prec.lowest(splViewPlugin)]);
    const renderSPLBlock = (source, el) => {
      const pre = el.createEl("pre", { cls: "spl-codeblock" });
      const code = pre.createEl("code");
      const tokens = tokenizeSPL(source);
      let result = "";
      let lastEnd = 0;
      for (const token of tokens) {
        if (token.start > lastEnd) {
          result += escapeHtml(source.slice(lastEnd, token.start));
        }
        result += `<span class="spl-${token.type}">${escapeHtml(source.slice(token.start, token.end))}</span>`;
        lastEnd = token.end;
      }
      if (lastEnd < source.length) {
        result += escapeHtml(source.slice(lastEnd));
      }
      code.innerHTML = result;
    };
    this.registerMarkdownCodeBlockProcessor("spl", (source, el, ctx) => renderSPLBlock(source, el));
    this.registerMarkdownCodeBlockProcessor("SPL", (source, el, ctx) => renderSPLBlock(source, el));
    this.registerMarkdownCodeBlockProcessor("Spl", (source, el, ctx) => renderSPLBlock(source, el));
    this.registerMarkdownCodeBlockProcessor("splunk", (source, el, ctx) => renderSPLBlock(source, el));
    this.registerMarkdownCodeBlockProcessor("SPLUNK", (source, el, ctx) => renderSPLBlock(source, el));
    this.registerMarkdownCodeBlockProcessor("Splunk", (source, el, ctx) => renderSPLBlock(source, el));
  }
  onunload() {
  }
};
function escapeHtml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
